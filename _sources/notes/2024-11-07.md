
+++{"lesson_part": "activity","ac_type":"prepare"}

1. In {index}`fractionalbinary.md` use 8 bits to represent the following numbers by using 4 bits as usual (8,4,2,1) and the other 4 bits are 1/2, 1/4, 1/8, 1/16th:
- 1.5
> 0001.1000
- 12.75
> 1100.1100
- 7.5625
> 0111.1001
- 15.9375
> 1111.1111
1. Add to your file some notes about the limitations of representing non integer values this way. How much would using more bits help with, what limitations are not resolved by adding more bits. For example, how could you represent .1? 
+++{"lesson_part": "main"}
# How does a computer represent non integer quantities?




+++{"lesson_part": "main"}

## prepare work

1. In {index}`fractionalbinary.md` use 8 bits to represent the following numbers by using 4 bits as usual (8,4,2,1) and the other 4 bits are 1/2, 1/4, 1/8, 1/16th:
- 1.5
- 12.75
- 7.5625
- 15.9375
  
1. Add to your file some notes about the limitations of representing non integer values this way. How much would using more bits help with, what limitations are not resolved by adding more bits. For example, how could you represent .1? 
+++{"lesson_part": "main"}

- 1.5
> 0001.1000
- 12.75
> 1100.1100
- 7.5625
> 0111.1001
- 15.9375
> 1111.1111

+++{"lesson_part": "main"}
- floating point
- IEEE double format

+++{"lesson_part": "main","type":"heading"}

## Prelude

What do we mean by representation?



+++{"lesson_part": "site"}

### negative numbers
we use one bit to represent the sign.  and then e have two choices for the rest of the bits: 

+++{"lesson_part":"site","type":"table"}

```{list-table}

* - representation
  - how to negate
  - how to read
* - ones complement
  - flip all the bits
  - note the sign, flip all the bits back
* - two's complement
  - flip the bits, add 1
  - note the sign, flip all the bits, add one
```

+++{"lesson_part": "main"}
Try it out on [integer exposed](https://integer.exposed/)

For example, set it to [3](https://integer.exposed/#0x03) and then use the `~` button to flip the bits and add one by flipping the 0 in the ones place to a 1 (add one), that ends up at [-3](https://integer.exposed/#0xfd)

so in 8 bit signed integer 3 is 00000011 and -3 is 11111101.

Try a few other cases in [integer exposed](https://integer.exposed/)

Two's complement is themost common

+++{"lesson_part": "main","type":"heading"}

## What about a fixed point for fractions?



+++{"lesson_part": "main"}


Let's experiment with an 8 bit representation with 1 bit for sign and then the next 4 used for the part of the  number greater than 0 and the last 3 for the fractional part.



+++{"lesson_part": "main"}

<!-- ![]() -->
<!-- drawing on fixed/flaot -->




<!-- ![]() -->
<!-- drawing on fixed/flaot -->




+++{"lesson_part": "main"}

 would be


```
0-1000-001
```
positive, 8.1




+++{"lesson_part": "main","type":"heading"}

## How many total numbers can we represent? 

in this then we can represent the numbers 0-8 for the right hand side and 0-15 on the left hand side so we get

+++{"lesson_part": "main"}

we can visualize values with [memory spy](https://memory-spy.wizardzines.com/game)

+++{"lesson_part": "main"}

We can visualize this in code using a little Python if we want: 

```python
import itertools
num_list = [str(n+f) for n,f in itertools.product(range(16),[i/10 for i in range(10)])]
', '.join(num_list) + ', '.join(['-'+ n for n in num_list])
```




+++{"lesson_part": "main"}


```python
len(num_list)*2
```


+++{"lesson_part": "main"}


This is far fewer different values than we could represent with 1 bit for sign and 7 bits to represent intergers



+++{"lesson_part": "main"}


```python
(2**7)*2
```



+++{"lesson_part": "main"}


Another way we could represent numbers with a fixed point, is to use base two fractions: $\frac{1}{2}$, $\frac{1}{4}$, $\frac{1}{8}$ etc.




+++{"lesson_part": "main"}


In this fixed point we would have, for example:
`0101.1010` would be $$0*2^3 + 1*2^2 + 0*2^2 + 1*2^0 + 1*\frac{1}{2^{-1}} + 0*\frac{1}{2^{-2}} + 1*\frac{1}{2^{-}} + 0*\frac{1}{2^{-4}} = 4 + 1 + \frac{1}{2} + \frac{1}{8} = 5 + \frac{5}{8}= 5.625$$




+++{"lesson_part": "main"}


In this case we still have a small range of numbers, but it's a different set of possible numbers.


+++{"lesson_part": "main","type":"heading"}



## Floating Point Notation



+++{"lesson_part": "main"}



We can write  numbers in many different forms. We have written integers through many different bases so far.



+++{"lesson_part": "main"}


For example in scientific contexts, we often write numbers (in base 10) like:




+++{"lesson_part": "main"}


$$
3.45 \times 10^2 = 345
$$





+++{"lesson_part": "main"}


We can use a similiar form to represent numbers in binary. Using base 2 instead of base 10.  




+++{"lesson_part": "main","type":"heading"}



## Floating point numbers are not all  exact



+++{"lesson_part": "main"}


Let's look at an example, we add `.1` together 3 times, and we get the expected result.
```python
.1 + .1 + .1
```


+++{"lesson_part": "main"}


However, if we check what it's equal to, it does not equal .3
```python
.1 + .1 + .1 == .3
```



+++{"lesson_part": "main"}


This is because the floating point representation is an *approximation* and there are multiple full numbers that are close to any given number that cannot be expressed exactly.
However, the display truncates since usually we want only a few significant digits.  
Even rounding does not make it work.


+++{"lesson_part": "main"}


```python
round(.1,1) + round(.1,1) + round(.1,1) == round(.3,1)
```


+++{"lesson_part": "site"}

```{important}
This matters because we cannot rely on equality tests for floats
```

Instead, we use subtraction and a tolerance:

```{code-cell} python
(.1+.1+.1 - .3)< .0001
```


+++{"lesson_part": "main"}


```python
round(.1 + .1+ .1 ,1)
```




+++{"lesson_part": "main"}


```python
.1
```




+++{"lesson_part": "main"}


```python
num = .1
```




+++{"lesson_part": "main"}


```python
num
```




+++{"lesson_part": "main","type":"heading"}


<!-- #region -->
## Floating point IEEE standard




+++{"lesson_part": "main"}


Now, lets see how these numbers are actually represented.


[float.exposed](https://float.exposed/0x2b3c3a80)

+++{"lesson_part": "main"}


[IEEE Floating Point ](https://ieeexplore.ieee.org/document/8766229)
is what basically everyone uses, but it is technically a choice hardware manufacturers can  make.


- Initially in 1985
- Reviesd in 2008 after 7 year process that expanded
- revised in 2019 after 4 year process that mostly added clarifications
- Next revision is projected to 2028.


+++{"lesson_part": "site"}

```{note}
IBM mainframes use their own representiton based on Hex*

```

+++{"lesson_part": "main"}


this is a double precision float or binary64 inthe current standard.  



+++{"lesson_part": "main"}


it was called double in the original, offically, so it is commonly called that still, even though it is no longer the formally correct name.


+++{"lesson_part": "main"}


In this case we will 1 bit for sign, 11 for exponent and 52 for the fraction part



+++{"lesson_part": "main"}


![float bit image](https://upload.wikimedia.org/wikipedia/commons/thumb/a/a9/IEEE_754_Double_Floating_Point_Format.svg/2560px-IEEE_754_Double_Floating_Point_Format.svg.png)


+++{"lesson_part": "main","type":"heading"}

### How do we read a number like this?



+++{"lesson_part": "main"}


if the sign bit is $s$ and the number represented by the exponent bits is $e$ and the 52 bits are number from right most is 0 and the last one is 52.



+++{"lesson_part": "main"}



$$
(-1)s + \left(1 + \sum_{i=1}^{52} b_{52-i} 2^{-i}\right) \times 2^{e-1023}
$$




+++{"lesson_part": "main"}


Note that this is $2^{-1}$ so we are working with *fractions* instead of integers in the sum.

+++{"lesson_part": "main"}


So if we had:



```
0 01111111111 0000000000000000000000000000000000000000000000000000
```

it would represent:



$$
(-1)*0 + \left(1 + 0 \cdot 2^{-0} + 0 \cdot 2^{-1} + \ldots  + 0 \cdot 2^{-51} + 0 \cdot 2^{-52} \right) \times 2^{1023-1023} = 0 + (1 + 0) \times 2^0  = 1 \times 1 =  1.0
$$



+++{"lesson_part": "main"}

So, for 
```
0 01111111111 0100000000000000000000000000000000000000000000000000
```

+++{"lesson_part": "main"}

following the equation, we get: 

$$ (-1)*0 + \left(1 + 0\cdot 2^{-1} + 1\cdot 2^{-2} + 0\cdot 2^{-3}  + \ldots  + 0\cdot 2^{-51} + 0\cdot 2^{-52} \right) \times 2^{1023-1023} = 0 + (1 + \frac{1}{4}) \times 2^0  = 1.25 \times 1 =  1.25 $$
<!-- #endregion -->




+++{"lesson_part": "main"}


```python
0b01111111111
```


+++{"lesson_part": "main"}


```python
float.hex(1.5)
```

+++{"lesson_part": "main"}



```python
0b01111111000-1023
```

+++{"lesson_part": "main"}

### Why use e-1023 for the exponent?


```{code-cell} python
2**11
```

so 1023 is half -1, this means that we split the possible range of numbers that we can represent in the exponent to positive and negative, meaning the whole expression $2^{e-1023}$ ranges from large($2^{1025}$) to small($2^{-1023}$) 


+++{"lesson_part": "main","type":"heading"}



### How do we get numbers into this form?



+++{"lesson_part": "main"}


Now, let's return to our example of .1.



+++{"lesson_part": "main"}


First we take the sign of the number for the sign bit, but then to get the exponent and fraction, we have more work to do.  



+++{"lesson_part": "main"}


Let's take the equation we had from the standard:



$$  \left(1 + \sum_{i=1}^{52} b_{52-i} 2^{-i}\right) \times 2^{e-1023}$$
<!-- #endregion -->



+++{"lesson_part": "main"}



If we think about the fraction and how we add fractions, by reaching a common denominator. Since they're all powers of two, we can use the last one.    


$$  \left(1 + \sum_{i=1}^{52} b_{52-i} 2^{-i}\right) \times 2^{e-1023}$$




+++{"lesson_part": "main"}

and we can expand the sum to a different notation for visual clarity

$$ \left( 1 + \frac{b_{52}}{2^{1}} + \frac{b_{51}}{2^{2}} + \cdots + \frac{b_{1}}{2^{51}} + \frac{b_{0}}{2^{52}} \right) \times 2^{e-1023} $$




+++{"lesson_part": "main"}


And apply a common denominator:




$$ \left(\frac{2^{52}}{2^{52}} + \frac{2^{51} b_{52}}{2^{52}} + \frac{2^{50} b_{51}}{2^{52}} + \cdots + \frac{2^{1} b_{1}}{2^{52}} + \frac{2^0 b_{0}}{2^{52}}  \right) \times 2^{e-{1023}} $$



+++{"lesson_part": "main"}


So then this becomes a binary number with 53 bits (the 52 + 1) and a denominator of $2^{52}$, let's call that number $J$ so we have:.


$$ \frac{J}{2^{52}}  \times 2^{e-{1023}} $$



+++{"lesson_part": "main"}


we can then combine the powers of 2.

$$ \frac{J}{2^{52-e+1023}} =  \frac{J}{2^{N}}  $$


+++{"lesson_part": "main"}


So in order to return to our `.1` that we want to represent, we can represent it as a fraction and then approximated it in the form above.



$$\frac{1}{10} \approx \frac{ J }{2^N}$$

**this  means approximately equal to**



+++{"lesson_part": "main"}

after some manipulation:

$$J ~= 2^N / 10$$




+++{"lesson_part": "main"}


 Since we want to use exactly 53 bits to represent $J$, we want $\frac{2^N }{10}$ to be greater than or equal to $2^{52}$ and less than $2^{53}$.



 $$ 2^{52} <= \frac{2^N }{10} < 2^{53} $$




+++{"lesson_part": "main"}

Since $8<10<16$ we can say $2^3<10<2^4$

and  we can also say that 

$$ \frac{1 }{2^4} < \frac{1 }{10} < \frac{1 }{2^3} $$ 

(larger denominators is smaller numbers if the numerators are the same) 



+++{"lesson_part": "main"}

We can put any numerator that is the same across all : 
 $$ \frac{2^N }{2^4} < \frac{2^N }{10} < \frac{2^N }{2^3} $$


+++{"lesson_part": "main"}

and simplify the outer ones to only have a single exponent

 $$ 2^{N-4} <  \frac{2^N }{10} < 2^{N-3} $$


+++{"lesson_part": "main"}

 so if we want:

 $$ 2^{52} <= \frac{2^N }{10} < 2^{53} $$

then best $N$ is 56,.

+++{"lesson_part": "main"}

We can confirm this in a calculator

```{code-cell} python
2**52 <= 2**46/10 < 2**53
```


+++{"lesson_part": "main"}


Now we can get the number we will use for $J$. We want to get as close to .1 with our fraction as possible, so
we get the quotient and remainder, the quotient will be the number we use, but we use the remainder to see if we round up or not


```python
q,r = divmod(2**56,10)
```


+++{"lesson_part": "main"}


Then we check the remainder to decide if we should round up by 1 or not.


```python
r
```



+++{"lesson_part": "main"}



$ 6 > 5 = \frac{10}{2}$  so we round up


+++{"lesson_part": "main"}



```python
q+1
```




+++{"lesson_part": "main"}



then we can check the length in bits of that number



```python
len(bin(q+1))-2
```

```{code-cell} python
len(bin(q+1) )-2
```

+++{"lesson_part": "main"}



```python
bin(q+1)
```

+++{"lesson_part": "main"}



We need $52-e+1023 = 56$ so



```python
52-56+1023
```



+++{"lesson_part": "main"}

Now lets' confirm what we found with the actual representation: 

Python doesn't provide a binary reprsentation of floats, but it does provide a hex representation.



```python
float.hex(.1)
```



+++{"lesson_part": "main"}


THat matches this for the part before the p.
`0b1 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010`



+++{"lesson_part": "main"}



after the p is the exponent of $-4 = 1019-1023$. Which matches the approximation we found.  




+++{"lesson_part": "main"}

We can also test by computing

```python
(q+1)/2**56 == .1
```



+++{"lesson_part": "main"}



this confirms that the approximaiton we found is the same as the float representation of .1.



```python
format(.1, '.17f')
```

